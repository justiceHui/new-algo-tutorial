---
title: "시간 복잡도, 공간 복잡도"
date: 2020-12-21 00:00:00
categories:
- Tutorial
tags:
- Tutorial
---

문제 해결을 위한 자료구조/알고리즘 공부에 앞서, 각종 알고리즘의 성능을 측정하는 지표인 시간 복잡도와 공간 복잡도에 대해 먼저 공부해봅시다.

### 알고리즘의 성능을 판단하는 척도
알고리즘의 성능을 판단하는 대표적인 척도는 다음과 같습니다.
1. 정확성 - 정확한 답을 구하는가
2. 작업량 - 얼마나 적은 연산을 필요로 하는가
3. 메모리 사용량 - 얼마나 적은 공간을 필요로 하는가
4. 단순성 - 얼마나 단순한가
5. 최적성 - 더 이상의 개선할 여지가 없을 만큼 최적화가 잘 되었는가

시간 복잡도와 공간 복잡도는 각각 작업량과 메모리 사용량을 나타내는 지표입니다. 온라인 저지 문제들에서 요구하는 시간 제한/메모리 제한과 직접적으로 연관되어 있기 때문에 꼭 알아야 합니다.

### 점근 표기법과 빅오 표기법
시간 복잡도는 알고리즘의 연산량을 데이터의 개수($N$)에 대해 수식으로 표현한 것입니다. 마찬가지로 공간 복잡도는 메모리 사용량을 데이터의 개수$N$에 대해 수식으로 표현한 것입니다.<br>
만약 $N$개의 정수가 주어졌을 때 덧셈을 $2N^2 + 3N - 5$번 한다면 시간 복잡도는 $T(N) = 2N^2 + 3N - 5$입니다.<br>
시간 복잡도가 $K$개의 항으로 표현된다고 모든 항을 전부 표기하면 너무 힘들 것입니다. 그래서 보통 점근 표기법을 사용합니다.

점근 표기법은 함수의 증가 양상을 다른 함수와의 비교로 표현하는 방법입니다. 가장 대표적인 표기법인 Big-O Notation을 알아봅시다.

> 상수 $c$와 $N_0$이 존재하여, $N \geq N_0$인 모든 $N$에 대해 $T(N) \leq c * f(N)$을 만족하면 $T(N) = O(f(N))$입니다.

실제 시간 복잡도 $T(N)$과 어떤 함수 $f(N)$이 있을 때, $N$이 어떤 지점($N_0$)을 넘어가면 무조건 $T(N)$이 $f(N)$의 상수배 이하라는 것을 의미합니다.<br>
**다시 말해, 적당히 큰 $N$에서 $T(N)$은 $f(N)$을 넘지 않는다는 것을 의미합니다.**

$T(N) = 2N^2 + 3N - 5$, $f(N) = N^2$이라고 합시다. $N_0 = 2, c = 3$이라고 하면 $N \geq 2$인 모든 $N$에 대해서 $2N^2 + 3N - 5 \leq 3N^2$이므로 $T(N) = O(N^2)$입니다. $T(N) = 917$처럼 시간 복잡도가 상수로 표현된다면 $f(N) = 1, N_0 = 0, c = 918$처럼 해서 $O(1)$로 표현할 수 있습니다.<br>
보통 Big-O Notation에서 최고차항이 아닌 항과 계수는 제외합니다. 그러므로 $O(3N^2)$이 아니라 $O(N^2)$으로 표현합니다.

### 예제
[BOJ8393 합](https://www.acmicpc.net/problem/8393)문제를 봅시다. 1부터 $N$까지의 합을 구하는 문제입니다.

```cpp
#include <stdio.h>

int naive(int n){
  int sum = 0;
  for(int i=1; i<=n; i++){
    sum += i;
  }
  return sum;
}

int fast(int n){
  int sum = n*(n+1)/2;
  return sum;
}

int main(){
  int n;
  scanf("%d", &n);
  printf("%d", fast(n));
}
```
`naive`함수와 `fast`함수 모두 문제를 풀 수 있습니다. 두 함수의 시간 복잡도를 계산해봅시다.<br>
naive함수는 덧셈을 $N$번 수행하기 때문에 $O(N)$입니다. fast함수는 덧셈, 곱셈, 나눗셈을 각각 1번씩 수행하므로 $O(1)$입니다.<br>
시간 복잡도 측면에서는 fast함수가 더 좋다고 할 수 있습니다.

이렇게 한 문제에 대해 여러 가지의 풀이가 나올 수 있습니다. 어떤 풀이는 주어진 시간 제한과 메모리 제한 안에 들어가서 문제를 풀 수 있을 것이고, 어떤 풀이는 제한을 넘겨 문제를 풀지 못할 수 있습니다. 시간 복잡도와 공간 복잡도를 잘 계산할 수 있다면, 자신이 설계한 알고리즘의 성능을 대략적으로 짐작해 최적화를 하는데 도움이 될 수 있을 것입니다.
