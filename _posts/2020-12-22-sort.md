---
title: "간단한 정렬 알고리즘"
date: 2020-12-22 00:00:00
categories:
- Tutorial
tags:
- Tutorial
---

간단한 정렬 알고리즘을 공부해보며 알고리즘이 무엇인지 체험해봅시다.

### 정렬 알고리즘
정렬 알고리즘이란, 주어진 원소들을 일정한 순서대로 나열하는 알고리즘입니다.<br>
문제가 간단하고 이해하기 쉬워서 그런지 컴퓨터 초창기부터 많은 연구가 진행되었습니다. 이 글에서는 간단한 정렬 알고리즘 5가지를 알아본 다음, 이 알고리즘을 이용해 (1) **알고리즘의 정당성 증명**, (2) **데이터의 형태에 따른 알고리즘 설계**, (3) **평균 시간 복잡도의 분석**을 배워보도록 하겠습니다.

### 버블 정렬 (Bubble Sort)
인접한 두 원소를 비교해서, 더 작은 원소가 앞에 오도록 교환하는 작업을 반복하는 정렬 알고리즘입니다.

첫 번째 단계에서는 1번째와 2번째 원소를 비교, 2번째와 3번째 원소를 비교, ... , N-1번째와 N번째 원소를 비교해서 각각 더 작은 원소가 앞에 오도록 정렬합니다. 가장 큰 원소가 N번째로 가게 됩니다.<br>
두 번째 단계에서도 마찬가지로 1/2번째 원소 비교, 2/3번째 원소 비교, ... , N-2/N-1번째 원소를 비교합니다. 두 번째로 큰 원소가 N-1번째로 가게 됩니다.<br>
이런 과정을 N-1번 거치면 모든 원소가 정렬됩니다.

55, 7, 78, 12, 42로 구성된 배열을 버블 정렬로 정렬해봅시다.
```
"55 07" 78 12 42 -> swap
07 "55 78" 12 42  
07 55 "78 12" 42 -> swap
07 55 12 "78 42" -> swap
"07 55" 12 42 78  
07 "55 12" 42 78 -> swap
07 12 "55 42" 78 -> swap
"07 12" 42 55 78  
07 "12 42" 55 78  
"07 12" 42 55 78  
"07 12 42 55 78"  정렬 끝
```

간단하게 구현할 수 있습니다.

```cpp
for(int i=1; i<=N-1; i++){
  for(int j=1; j<=N-i; j++){
    if(A[j] > A[j+1]){
      swap(A[j], A[j+1]);
    }
  }
}
```

두 번째 루프는 첫 단계에서 N-1번, 두 번째 단계에서 N-1번, ... N-1번째 단계에서 1번 돕니다. 반복 횟수가 $\frac{N(N-1)}{2}$이므로 시간 복잡도는 $O(N^2)$이라고 나타낼 수 있습니다.

### 선택 정렬 (Selection Sort)
선택 정렬은 가장 작은 원소를 찾은 다음, 그 원소를 맨 뒤로 보내는 알고리즘입니다.

첫 번째 단계에서는 1..N번째 원소 중 가장 작은 원소를 선택해서 1번 원소와 교환합니다. 가장 작은 원소가 맨 앞으로 가게 됩니다.<br>
두 번째 단계에서는 2..N번째 원소 중 가장 작은 원소를 선택해서 2번 원소와 교환합니다. 두 번째로 작은 원소가 두 번째 자리로 가게 됩니다.<br>
이런 과정을 N-1번 거치면 모든 원소가 정렬됩니다.

2, 5, 3, 1, 4, 7, 6로 구성된 배열을 선택 정렬로 정렬해봅시다.
```
/ 2 5 3 "1" 4 7 6
1/ 5 3 "2" 4 7 6
1 2 3/ 5 "4" 7 6
1 2 3 4 5/ 7 "6"
1 2 3 4 5 6 7 /
```

뒤에서부터 정렬되는 버블 정렬과 달리 선택 정렬은 앞부터 정렬됩니다.

간단하게 구현할 수 있습니다.
```cpp
for(int i=1; i<=N-1; i++){
  int idx = i;
  for(int j=i; j<=N; j++){
    if(A[j] < A[idx]) idx = j;
  }
  swap(A[i], A[j]);
}
```

두 번째 루프는 첫 단계에서 N번, 두 번째 단계에서 N-1번, ... , N번째 단계에서 1번 돕니다. 반복 횟수가 $\frac{N(N-1)}{2}$이므로 시간 복잡도는 $O(N^2)$이라고 나타낼 수 있습니다.

### 삽입 정렬 (Insertion Sort)
삽입 정렬은 모든 원소를 차례대로 보면서, 현재 원소를 이미 정렬된 부분과 비교하여 적절한 위치에 삽입하는 방식으로 정렬합니다.

$i$번째 단계가 완료되면 1..$i$번째 원소를 정렬된 상태가 되도록 유지합니다. 이후 $i+1$단계에서 $i+1$번째 원소를 이미 정렬된 부분에서 적절한 위치를 찾아 **삽입**합니다.

31, 25, 12, 22, 11로 구성된 배열을 삽입 정렬로 정렬해봅시다.
```
"31" 25 12 22 11    첫번째 원소인 31을 적절한 위치에 넣는다.
31 "25" 12 22 11    두번째 원소인 25를 적절한 위치에 넣는다.
25 31 "12" 22 11    세번째 원소인 12를 적절한 위치에 넣는다.
12 25 31 "22" 11    네번째 원소인 22를 적절한 위치에 넣는다.
12 22 25 31 "11"    다섯번째 원소 11을 적절한 위치에 넣는다.
11 12 22 25 31
```

버블 정렬과 선택 정렬에 비해 구현은 다소 어려울 수 있습니다.
```cpp
for(int i=1; i<=N; i++){
  int j = i;
  while(j > 1 && A[j-1] > A[j]){
    swap(A[j-1], A[j]);
    j--;
  }
}
```

최악의 경우, $i$번째 단계에서 while문이 $i-1$번 돌기 때문에 시간 복잡도는 $O(N^2)$이 됩니다.

### 기수 정렬 (Redix Sort)
주로 문자열이나 정수 자료형을 정렬하는데 사용하는 알고리즘입니다.

낮은 자리 수부터 비교하여 정렬합니다. 10진법 자연수들을 정렬한다고 합시다.<br>
첫 번째 단계에서는 $10^0$(= 1)의 자리 수만 보면서 정렬합니다.<br>
두 번째 단계에서는 $10^1$(= 10)의 자리 수만 보면서 정렬합니다. 이때 10의 자리 수가 같다면 먼저 나온 원소가 앞에 오도록 합니다.<br>
$i$번째 단계에서는 $10^{i-1}$의 자리 수만 보면서 정렬합니다.

직관적으로 와닿지 않을 수 있으니 예제를 봅시다.<br>
170, 45, 75, 90, 2, 24, 802, 66로 구성된 배열을 기수 정렬을 이용해 정렬할 것입니다.

먼저, 1의 자리만 보고 정렬을 하면 170, 90, 2, 802, 24, 45, 75, 66이 됩니다.<br>
이 배열을 다시 10의 자리만 보고 정렬을 하면 2, 802, 24, 25, 66, 170, 75, 90이 됩니다.<br>
마지막으로 100의 자리를 기준으로 정렬하면 2, 24, 45, 66, 75, 90, 170, 802가 되면서 정렬이 완료됩니다.

시간 복잡도는 $O(dN)$이 됩니다. 이때 $d$는 가장 긴 원소의 길이입니다. 위 예제에서는 170, 802가 가장 길기 때문에 $d = 3$이 되겠지요.<br>
문자열을 정렬할 때는 $i$번째 단계에서 $d-i$번째(0-based) 문자를 기준으로 정렬하면 됩니다.

코드로 구현할 때는 큐(Queue)라는 자료구조를 사용합니다. 큐는 먼저 들어간 원소가 먼저 나오는 자료구조로, 대기열이라고 생각하면 됩니다. 현재 정렬 기준으로 잡은 자리가 같으면 **먼저 나온 원소가 앞에 오도록** 정렬하는 기수 정렬과 잘 맞는 구조입니다.

170, 45, 75, 90, 2, 24, 802, 66의 정렬 과정을 다시 한 번 살펴봅시다.<br>
10진법이므로 큐를 10개 생성해 각각 0번 큐, 1번 큐, ... , 9번 큐라고 번호를 붙입시다. 그 다음 1의 자리를 기준으로 큐에 삽입합니다.<br>
0번 큐(170, 90), 2번 큐(2, 802), 4번 큐(24), 5번 큐(45, 75), 6번 큐(66)처럼 들어가게 됩니다.<br>
0번 큐부터 9번 큐까지 원소를 차례대로 꺼내면 170, 90, 2, 802, 24, 45, 75, 66이 되어 1의 자리 기준으로 정렬이 됩니다.

이 과정을 $d$번 반복해주면 됩니다.

구현 코드는 뒤에 자료구조 큐(Queue)에 대해 공부할 때 같이 보도록 하겠습니다.

### 계수 정렬 (Counting Sort)
주로 자연수를 정렬하는데 사용하는 알고리즘입니다.

원소들 중 최댓값을 X라고 합시다. 크기가 X인 배열을 만들어 각 원소가 몇 번 등장했는지 기록한 다음, 마지막에 배열을 차례대로 보면서 등장한 횟수만큼 출력하는 알고리즘입니다.

구현은 매우 간단합니다.
```cpp
int cnt[X+1];
for(int i=1; i<=N; i++){
  cnt[a[i]]++;
}
for(int i=1; i<=X; i++){
  for(int j=1; j<=cnt[i]; j++){
    printf("%d ", i);
  }
}
```

시간 복잡도는 $O(N+X)$, 공간 복잡도는 $O(X)$입니다.

### 정리
지금까지 버블 정렬, 선택 정렬, 삽입 정렬, 기수 정렬, 계수 정렬, 총 5가지의 정렬 알고리즘을 알아보았습니다.

이제 이 5가지 알고리즘을 이용해서 (1) 알고리즘의 정당성 증명, (2) 데이터의 형태에 따른 알고리즘 설계, (3) 평균 시간 복잡도의 분석을 알아봅시다.

### 알고리즘의 정당성 증명 : 반복문 불변식
반복문 불변식이란, 반복문의 각 단계가 실행될 때마다 **중간 결과가 제대로 나오는지** 명시하는 조건입니다. 귀납법의 일종입니다.<br>
알고리즘의 정당성을 아래 과정을 통해 증명합니다.

1. 반복문에 처음 진입할 때 불변식이 성립함을 보인다.
2. 반복문의 내용이 불변식을 깨뜨리지 않음을 보인다.
3. 반복문 종료 시 불변식이 성립함을 보인다.

삽입 정렬을 예시로 불변식을 세워봅시다.
```cpp
for(int i=1; i<=N; i++){
  // 불변식 1: A[1..i-1]은 이미 정렬되어 있다.
  int j = i;
  while(j > 1 && A[j-1] > A[j]){
    swap(A[j-1], A[j]);
    // 불변식 2: A[j+1..i]의 모든 원소는 A[j]보다 크다.
    j--;
  }
}
```

불변식 1, 2가 항상 성립함을 보이면 되고, 이는 쉽게 보일 수 있으므로 독자들에게 연습 문제로 남기겠습니다.

### 데이터의 형태에 따른 알고리즘 설계
A라는 배열에는 10억 이하의 자연수가 1000개 들어있습니다.<br>
B라는 배열에는 100 이하의 자연수가 10만 개 들어있습니다.

두 배열을 정렬할 때 어떤 알고리즘을 사용해야 할까요?

A배열을 선택 정렬을 이용해 정렬한다면 대략 100만 번의 연산으로 배열을 정렬할 수 있습니다. 계수 정렬을 이용한다면 대략 10억 번의 연산을 수행해야 배열을 정렬할 수 있습니다. A 배열에는 계수 정렬보다는 선택 정렬을 사용하는 것이 좋겠네요.

그러면 B배열도 선택 정렬을 사용하는 것이 좋을까요?<br>
B배열을 선택 정렬로 정렬하기 위해서는 대략 100억 번의 연산을 수행해야 정렬할 수 있습니다. 하지만 계수 정렬을 이용한다면 10만 번의 연산만으로 배열을 정렬할 수 있습니다. A 배열과는 다르게 B배열에서는 계수 정렬이 훨씬 좋네요.

선택 정렬은 단순히 **데이터의 개수**에만 영향을 받고, 계수 정렬은 **데이터의 형태**에도 영향을 받습니다. 데이터의 형태에 따라 적절한 알고리즘을 선택하는 것이 좋고, 실제로 경시 대회에 출제되는 몇몇 여러운 문제는 이런 능력을 요구하기도 합니다.

### 평균 시간 복잡도의 분석
삽입 정렬도 데이터의 형태에 따라 연산량이 달라집니다.<br>
이미 정렬된 배열은 삽입 과정이 생략되므로 시간 복잡도가 $O(N)$이 되지만, 역순으로 정렬된 배열은 $\frac{N(N-1)}{2}$번의 교환을 해야 합니다.

잘 생각해보면 삽입 정렬에서 교환 연산의 횟수는, 각 원소마다 **앞에 있는 원소 중 자신보다 큰 원소의 개수**를 합한 것과 같습니다. 이를 Inversion이라고 부릅니다.<br>
삽입 정렬의 평균적인 경우에 대한 시간 복잡도를 계산해봅시다.

계산의 편의를 위해 순열(1부터 $N$까지의 수가 한 번씩 등장하는 배열)을 정렬한다고 가정합시다. $N!$가지의 모든 순열에서 Inversion의 합을 구한 뒤, $N!$으로 나눠주면 됩니다.

서로 다른 두 자연수 $i, j$에 대해 $i$가 $j$보다 앞에 있는 순열은 $\frac{N!}{2}$이고, $i$가 더 뒤에 있는 경우도 $\frac{N!}{2}$입니다. 두 자연수 $i, j$만 고려했을 때 모든 순열에서 Inversion의 합은 $\frac{N!}{2}$입니다.<br>
모든 자연수 쌍 $(i, j)$에 대해 이 값을 더하면 ${N \choose 2} \times \frac{N!}{2}$가 되고, 이것을 $N!$으로 나누면 $\frac{N(N-1)}{4}$이 됩니다.

그러므로 삽입 정렬의 평균 시간 복잡도(혹은 임의의 순열의 Inversion의 기댓값)는 $\frac{N(N-1)}{4}$이 됩니다.
